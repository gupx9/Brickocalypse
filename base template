from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import math, time, random, sys
from OpenGL.GLUT import GLUT_BITMAP_HELVETICA_18


# ----------------- Window -----------------
WIN_W, WIN_H = 1000, 800
ASPECT = WIN_W / WIN_H
FOVY = 75.0

# ----------------- Game Settings -----------------
CELL = 60.0
GRID_ROWS = 10
GRID_COLS = 10
HALF_W = GRID_COLS * CELL * 0.5
HALF_H = GRID_ROWS * CELL * 0.5

# ----------------- Player -----------------
player_pos = [0.0, -HALF_H + CELL, 0.0]
player_angle = 0.0
player_speed = 220.0
PLAYER_RADIUS = 20.0
lives = 3
invincible_timer = 0

# ----------------- Tower -----------------
tower_pos = [0.0, 0.0]
tower_height = 0
TOWER_LAYER_HEIGHT = 15
MAX_TOWER_HEIGHT = 8  # layers to win
tower_health = MAX_TOWER_HEIGHT

# ----------------- Tower Pieces -----------------
pieces = []
pieces_count = 8  # increased from 5
PIECE_RADIUS = 15

# ----------------- Zombies -----------------
zombies = []
ZOMBIE_COUNT = 4
zombie_speed = 20  # reduced from 80
spawn_timer = 0
SPAWN_INTERVAL = 5.0  # seconds between zombie spawns

# ----------------- Bullets -----------------
bullets = []
bullet_speed = 500.0  # increased from 400
BULLET_COOLDOWN = 0.3  # seconds between shots
last_shot_time = 0

# ----------------- Game State -----------------
score = 0
game_over = False
game_won = False
first_person = False
cam_orbit_angle = 180.0  # facing -Y axis
cam_height = 280.0
last_time = None
keys_down = set()
quadric = None

# ----------------- Helper Functions -----------------
def all_pieces_collected():
    return len(pieces) == 0

# ----------------- Spawning -----------------
def spawn_pieces():
    global pieces
    pieces.clear()
    for _ in range(pieces_count):
        while True:
            x = random.uniform(-HALF_W+CELL, HALF_W-CELL)
            y = random.uniform(-HALF_H+CELL, HALF_H-CELL)
            if math.hypot(x - tower_pos[0], y - tower_pos[1]) > CELL*2:
                pieces.append([x, y])
                break

def spawn_zombies(count=1):
    global zombies
    for _ in range(count):
        side = random.randint(0, 3)
        if side == 0:  # top
            x = random.uniform(-HALF_W, HALF_W)
            y = HALF_H - CELL
        elif side == 1:  # right
            x = HALF_W - CELL
            y = random.uniform(-HALF_H, HALF_H)
        elif side == 2:  # bottom
            x = random.uniform(-HALF_W, HALF_W)
            y = -HALF_H + CELL
        else:  # left
            x = -HALF_W + CELL
            y = random.uniform(-HALF_H, HALF_H)
        zombies.append({
            'pos': [x, y, 0], 
            'pulse': random.random()*math.pi*2,
            'health': 2
        })

# ----------------- Game Reset -----------------
def reset_game():
    global player_pos, player_angle, tower_height, tower_health, score, lives
    global game_over, game_won, invincible_timer, spawn_timer, last_shot_time
    
    player_pos[:] = [0.0, -HALF_H + CELL, 0.0]
    player_angle = 0.0
    tower_height = 0
    tower_health = MAX_TOWER_HEIGHT
    score = 0
    lives = 3
    game_over = False
    game_won = False
    invincible_timer = 0
    spawn_timer = 0
    last_shot_time = 0
    
    spawn_pieces()
    zombies.clear()
    spawn_zombies(ZOMBIE_COUNT)
    bullets.clear()

# ----------------- Drawing Functions -----------------
def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1, 1, 1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WIN_W, 0, WIN_H)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def draw_floor():
    glColor3f(0.2, 0.6, 0.2)
    glBegin(GL_QUADS)
    glVertex3f(-HALF_W, -HALF_H, 0)
    glVertex3f(HALF_W, -HALF_H, 0)
    glVertex3f(HALF_W, HALF_H, 0)
    glVertex3f(-HALF_W, HALF_H, 0)
    glEnd()

def draw_pieces():
    glColor3f(1.0, 0.5, 0.0)
    for x, y in pieces:
        glPushMatrix()
        glTranslatef(x, y, TOWER_LAYER_HEIGHT/2)
        glScalef(PIECE_RADIUS, PIECE_RADIUS, TOWER_LAYER_HEIGHT)
        glutSolidCube(1.0)
        glPopMatrix()

def draw_tower():
    for i in range(tower_height):
        glPushMatrix()
        glTranslatef(tower_pos[0], tower_pos[1], TOWER_LAYER_HEIGHT*(0.5+i))
        health_ratio = tower_health / MAX_TOWER_HEIGHT
        glColor3f(0.8, 0.8*health_ratio, 0.2*health_ratio)
        glScalef(40, 40, TOWER_LAYER_HEIGHT)
        glutSolidCube(1.0)
        glPopMatrix()
    if tower_height < MAX_TOWER_HEIGHT:
        glPushMatrix()
        glTranslatef(tower_pos[0], tower_pos[1], TOWER_LAYER_HEIGHT*(0.5+tower_height))
        glColor3f(0.5, 0.5, 0.5)
        glScalef(40, 40, 2)
        glutWireCube(1.0)
        glPopMatrix()

def draw_player():
    glPushMatrix()
    glTranslatef(player_pos[0], player_pos[1], PLAYER_RADIUS)
    glRotatef(player_angle, 0, 0, 1)
    if invincible_timer > 0 and int(time.time() * 10) % 2 == 0:
        glColor3f(1.0, 1.0, 1.0)
    else:
        glColor3f(0.1, 0.1, 1.0)
    gluSphere(quadric, PLAYER_RADIUS, 16, 16)
    glColor3f(0.3, 0.3, 0.3)
    glRotatef(90, 0, 1, 0)
    gluCylinder(quadric, 3, 3, 25, 8, 1)
    glPopMatrix()

def draw_zombies(t):
    colors = [(1.0,0.0,0.0), (0.0,1.0,0.0), (1.0,0.5,0.0), (1.0,0.0,1.0)]
    for i, z in enumerate(zombies):
        x, y, z_pos = z['pos']
        pulse = 2 * math.sin(t*3 + z['pulse'])
        glPushMatrix()
        glTranslatef(x, y, 15 + pulse)
        glColor3f(*colors[i%len(colors)])
        gluSphere(quadric, 15 + pulse, 12, 12)
        if z['health'] < 2:
            glColor3f(1.0, 1.0, 1.0)
            glTranslatef(0, 0, 20 + pulse)
            glutSolidSphere(5, 8, 8)
        glPopMatrix()

def draw_bullets():
    glColor3f(1.0, 1.0, 0.8)
    for b in bullets:
        x, y, z = b['pos']
        glPushMatrix()
        glTranslatef(x, y, z)
        glScalef(5, 5, 15)
        glutSolidCube(1.0)
        glPopMatrix()

# ----------------- Game Logic -----------------
def is_free(x, y):
    return -HALF_W < x < HALF_W and -HALF_H < y < HALF_H

def try_move(sign, dt):
    dx = math.cos(math.radians(player_angle)) * player_speed * dt * sign
    dy = math.sin(math.radians(player_angle)) * player_speed * dt * sign
    new_x = player_pos[0] + dx
    new_y = player_pos[1] + dy
    if is_free(new_x, new_y):
        player_pos[0] = new_x
        player_pos[1] = new_y

def collect_pieces():
    global tower_height, score, tower_health
    for p in pieces[:]:
        if math.hypot(player_pos[0]-p[0], player_pos[1]-p[1]) < PLAYER_RADIUS + PIECE_RADIUS:
            pieces.remove(p)
            tower_height = min(tower_height + 1, MAX_TOWER_HEIGHT)
            score += 20
            tower_health = min(tower_health + 1, MAX_TOWER_HEIGHT)
            if tower_height % 2 == 0 and tower_height > 0:
                spawn_zombies(1)

def update_zombies(dt):
    global lives, tower_health, game_over, invincible_timer
    if invincible_timer > 0:
        invincible_timer -= dt
    for z in zombies[:]:
        zx, zy, _ = z['pos']
        tower_dist = math.hypot(zx - tower_pos[0], zy - tower_pos[1])
        player_dist = math.hypot(zx - player_pos[0], zy - player_pos[1])
        if tower_dist < 200:
            dirx = tower_pos[0] - zx
            diry = tower_pos[1] - zy
        else:
            dirx = player_pos[0] - zx
            diry = player_pos[1] - zy
        dist = math.hypot(dirx, diry) + 1e-6
        z['pos'][0] += dirx/dist * zombie_speed * dt
        z['pos'][1] += diry/dist * zombie_speed * dt
        if tower_dist < 30:
            tower_health -= 1
            zombies.remove(z)
            spawn_zombies(1)
            if tower_health <= 0:
                game_over = True
        if player_dist < PLAYER_RADIUS + 15 and invincible_timer <= 0:
            lives -= 1
            invincible_timer = 2.0
            zombies.remove(z)
            spawn_zombies(1)
            if lives <= 0:
                game_over = True

def update_bullets(dt):
    global bullets, score
    for b in bullets[:]:
        b['pos'][0] += math.cos(math.radians(b['angle'])) * bullet_speed * dt
        b['pos'][1] += math.sin(math.radians(b['angle'])) * bullet_speed * dt
        if not is_free(b['pos'][0], b['pos'][1]):
            bullets.remove(b)
        else:
            for z in zombies[:]:
                if math.hypot(z['pos'][0]-b['pos'][0], z['pos'][1]-b['pos'][1]) < 20:
                    z['health'] -= 1
                    if z['health'] <= 0:
                        zombies.remove(z)
                        score += 15
                        spawn_zombies(1)
                    if b in bullets:
                        bullets.remove(b)
                    break

def check_win_condition():
    global game_won
    if tower_height >= MAX_TOWER_HEIGHT:
        game_won = True

# ----------------- Camera -----------------
def setup_camera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(FOVY, ASPECT, 0.1, 3000.0)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    if first_person:
        eye_x = player_pos[0] + math.cos(math.radians(player_angle)) * 10
        eye_y = player_pos[1] + math.sin(math.radians(player_angle)) * 10
        eye_z = 30
        center_x = eye_x + math.cos(math.radians(player_angle))
        center_y = eye_y + math.sin(math.radians(player_angle))
        center_z = 28
        gluLookAt(eye_x, eye_y, eye_z, center_x, center_y, center_z, 0, 0, 1)
    else:
        rad = math.radians(cam_orbit_angle)
        eye_x = player_pos[0] + math.cos(rad) * 400
        eye_y = player_pos[1] + math.sin(rad) * 400
        gluLookAt(eye_x, eye_y, cam_height, player_pos[0], player_pos[1], 20, 0, 0, 1)

# ----------------- GLUT Callbacks -----------------
def draw_ui():
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WIN_W, 0, WIN_H)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    draw_text(10, WIN_H-30, 
             f"Score: {score}  Lives: {lives}  Tower: {tower_height}/{MAX_TOWER_HEIGHT}  Health: {tower_health}")
    if game_over:
        if game_won:
            draw_text(WIN_W//2-100, WIN_H//2+20, "YOU WIN! (Press R)")
        else:
            draw_text(WIN_W//2-100, WIN_H//2+20, "GAME OVER (Press R)")
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def display():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    glViewport(0, 0, WIN_W, WIN_H)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(FOVY, ASPECT, 0.1, 3000.0)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    setup_camera()
    draw_floor()
    draw_pieces()
    draw_tower()
    current_time = glutGet(GLUT_ELAPSED_TIME) * 0.001
    draw_zombies(current_time)
    draw_player()
    draw_bullets()
    draw_ui()
    glutSwapBuffers()

def idle():
    global last_time
    now = time.time()
    if last_time is None:
        last_time = now
    dt = min(0.033, now - last_time)
    last_time = now
    if not game_over and not game_won:
        if 'A' in keys_down:
            global player_angle
            player_angle += 120 * dt
        if 'D' in keys_down:
            player_angle -= 120 * dt
        if 'W' in keys_down:
            try_move(+1, dt)
        if 'S' in keys_down:
            try_move(-1, dt)
        collect_pieces()
        update_zombies(dt)
        update_bullets(dt)
        check_win_condition()
    glutPostRedisplay()

def keyboard(key,x,y):
    try: k = key.decode('utf-8').lower()
    except: k = chr(key).lower()
    if k=='w': keys_down.add('W')
    if k=='s': keys_down.add('S')
    if k=='a': keys_down.add('A')
    if k=='d': keys_down.add('D')
    if k=='r': reset_game()
    if k=='\x1b': sys.exit(0)

def keyboard_up(key,x,y):
    try: k = key.decode('utf-8').lower()
    except: k = chr(key).lower()
    if k=='w': keys_down.discard('W')
    if k=='s': keys_down.discard('S')
    if k=='a': keys_down.discard('A')
    if k=='d': keys_down.discard('D')

def special(key,x,y):
    global cam_orbit_angle, cam_height
    if key==GLUT_KEY_LEFT: cam_orbit_angle += 2.5
    if key==GLUT_KEY_RIGHT: cam_orbit_angle -= 2.5
    if key==GLUT_KEY_UP: cam_height += 10
    if key==GLUT_KEY_DOWN: cam_height = max(60, cam_height-10)

def mouse(button,state,x,y):
    global first_person, last_shot_time
    if button==GLUT_LEFT_BUTTON and state==GLUT_DOWN:
        now = time.time()
        if now - last_shot_time >= BULLET_COOLDOWN and not game_over:
            bullets.append({'pos':[player_pos[0], player_pos[1], PLAYER_RADIUS], 'angle':player_angle})

            last_shot_time = now
    if button==GLUT_RIGHT_BUTTON and state==GLUT_DOWN:
        first_person = not first_person

def dummy_reshape(w, h):
    pass

# ----------------- OpenGL Initialization -----------------
def init_gl():
    global quadric
    glClearColor(0.05, 0.05, 0.09, 1.0)
    glEnable(GL_DEPTH_TEST)
    glEnable(GL_COLOR_MATERIAL)
    glShadeModel(GL_SMOOTH)
    glEnable(GL_LIGHTING)
    glEnable(GL_LIGHT0)
    glLightfv(GL_LIGHT0, GL_POSITION, [0, 0, 100, 1])
    glLightfv(GL_LIGHT0, GL_AMBIENT, [0.2, 0.2, 0.2, 1])
    glLightfv(GL_LIGHT0, GL_DIFFUSE, [0.8, 0.8, 0.8, 1])
    quadric = gluNewQuadric()
    gluQuadricNormals(quadric, GLU_SMOOTH)

# ----------------- Main -----------------
glutInit()
glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH)
glutInitWindowSize(WIN_W, WIN_H)
glutCreateWindow(b"Tower Defense OpenGL")
init_gl()
reset_game()
glutDisplayFunc(display)
glutIdleFunc(idle)
glutKeyboardFunc(keyboard)
glutKeyboardUpFunc(keyboard_up)
glutSpecialFunc(special)
glutMouseFunc(mouse)
glutReshapeFunc(dummy_reshape)
glutMainLoop()
